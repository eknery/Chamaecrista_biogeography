xexp= 1.2,
yexp= 1,
spacer=10,
colors= color_list)
### plot
plotTree.datamatrix(tree = tr,
X = tmp,
fsize= 0.3,
xexp= 1.2,
yexp= 1,
lwd=12,
colors= color_list)
### plot
plotTree.datamatrix(tree = tr,
X = tmp,
fsize= 0.3,
xexp= 1.2,
yexp= 1,
lwd=20,
colors= color_list)
## node marginal ML
relprobs_matrix = res$ML_marginal_prob_each_state_at_branch_top_AT_node
relprobs_matrix
node_states = get_ML_states_from_relprobs(relprobs= relprobs_matrix,
statenames= state_labels,
returnwhat = "states",
if_ties = "takefirst")
## node states
state_labels=c("A", "B", "C", "D", "E", "F", "G", "H")
node_states = get_ML_states_from_relprobs(relprobs= relprobs_matrix,
statenames= state_labels,
returnwhat = "states",
if_ties = "takefirst")
relprobs_matrix
View(relprobs_matrix)
node_states
### plot
plotTree.datamatrix(tree = tr,
X = tmp,
fsize= 0.3,
xexp= 1.2,
yexp= 1,
colors= color_list)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
#colors=c("#FFFFFF",colors_list_for_states[1:6]),
standardize=F)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
#colors=c("#FFFFFF",colors_list_for_states[1:6]),
standardize=T)
tmp
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
#colors=c("#FFFFFF",colors_list_for_states[1:6]),
standardize=F)
colors_list_for_states
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=c("#FFFFFF",color_list[1:6]),
standardize=F)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_list,
standardize=F)
color_vec = c(
"A" = "darkgreen",
"B" = "darkorange",
"C" = "darkgoldenrod",
"D" = "brown",
"E" = "darkblue",
"F" = "darkmagenta",
"G" = "deeppink",
"H" = "darkgray"
)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
standardize=F)
tmp
### creating binary spp x areas
tmp = tipranges@df
View(tmp)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
standardize=F)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
standardize=T)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
standardize=F)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
phylo.heatmap(tr,
X=tmp,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
phylo.heatmap(tr,
X=as.matrix(tmp),
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
as.matrix(tmp)
lapply(tmp, numeric)
tmp[, 1:ncol(tmp)] = lapply(tmp, as.numeric)
lapply(tmp, as.numeric)
### creating binary spp x areas
tmp = tipranges@df
tmp[, 1:ncol(tmp)] = lapply(tmp, as.numeric)
as.matrix(tmp)
phylo.heatmap(tr,
X=as.matrix(tmp),
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
1:ncol(tmp)
i = 1
tmp[[,i]]
tmp[,i]
one_col = tmp[,i]
one_col == 1
one_col[one_col == 1] = 2
one_col
### creating binary spp x areas
states_bin = tipranges@df
states_num = states_bin
states_num = states_bin
for(i in 1:ncol(states_bin)){
one_col = states_bin[,i]
one_col[one_col == 1] = i
states_num[,i] = one_col
}
states_num
phylo.heatmap(tr,
X=as.matrix(states_num),
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
states_num
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=T)
color_vec
color_vec = c(
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"darkgray"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
color_vec
data(anoletree)
data(anole.data)
## compute phylogenetic residuals
anole.data<-as.matrix(anole.data)
anole.data
anole.resids<-cbind(anole.data[,1],
phyl.resid(anoletree,anole.data[,1,drop=FALSE],
anole.data[,2:ncol(anole.data)])$resid)
anole.resids
phylo.heatmap(anoletree,anole.resids)
states_num
anole.resids
as.matrix(state_num)
as.matrix(states_num)
states_num = c()
for(i in 1:ncol(states_bin)){
one_col = as.numeric(states_bin[,i])
one_col[one_col == 1] = i
states_num = cbind(states_num, one_col)
}
states_num
row.names(states_num)
row.names(states_bin)
### creating numeric matrix
states_num = c()
for(i in 1:ncol(states_bin)){
one_col = as.numeric(states_bin[,i])
one_col[one_col == 1] = i
states_num = cbind(states_num, one_col)
}
### naminng
row.names(states_num) = row.names(states_bin)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
color_vec = c(
"white"
"darkgreen",
color_vec = c(
"white",
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"darkgray"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
col.names(sate_bin)
colnames(sate_bin)
colnames(state_bin)
colnames(states_bin)
colnames(state_num) = colnames(states_bin)
colnames(states_num) = colnames(states_bin)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
color_vec = c(
"lightgray",
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"darkgray"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
color_vec = c(
"gray80",
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"darkgray"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
color_vec = c(
"gray90",
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"darkgray"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.8,0.2),
standardize=F)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.9,0.1),
standardize=F)
color_vec = c(
"gray90",
"darkgreen",
"darkorange",
"darkgoldenrod",
"brown",
"darkblue",
"darkmagenta",
"deeppink",
"black"
)
phylo.heatmap(tr,
X=states_num,
fsize=c(0.3,0.75,0.5),
colors=color_vec,
split= c(0.9,0.1),
standardize=F)
res$ML_marginal_prob_each_state_at_branch_top_AT_node
### libraries
library("ape")
library("rexpokit")
library("cladoRcpp")
library("BioGeoBEARS")
### phylogenetic tree location
trfn = "5_posterior/mcc.tree"
tr = read.tree(file = trfn)
### reading range data
geog_fn = ("6_biogeo_data/macro_biogeo.data")
moref(geog_fn)
### converting phylip format to tipranges
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geog_fn)
tipranges
### setting maximum number of areas occupied for reconstructions
max_range_size = max(rowSums(dfnums_to_numeric(tipranges@df)))
### time strata and dispersal matrices
timesfn = "6_biogeo_data/model1_times.txt"
areas_allowed_fn = "6_biogeo_data/model2_areas_allowed.txt"
dispersal_multipliers_fn = "6_biogeo_data/model2_dispersal_multi.txt"
### Initialize DEC model
dec2 = define_BioGeoBEARS_run()
### inputting tree into DEC
dec2$trfn = trfn
### location of the geography text file
dec2$geogfn = geogfn
### phylogenetic tree location
trfn = "5_posterior/mcc_chamaecrista.tree"
tr = read.tree(file = trfn)
### reading range data
geogfn = "6_biogeo_data/micro_biogeo.data"
moref(geogfn)
### converting phylip format to tipranges
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn= geogfn)
tipranges
### setting maximum number of areas occupied for reconstructions
max_range_size = max(rowSums(dfnums_to_numeric(tipranges@df)))
### time strata and dispersal matrices
timesfn = "6_biogeo_data/model1_times.txt"
areas_allowed_fn = "6_biogeo_data/model2_areas_allowed.txt"
dispersal_multipliers_fn = "6_biogeo_data/model2_dispersal_multi.txt"
### Initialize DEC model
dec2 = define_BioGeoBEARS_run()
### inputting tree into DEC
dec2$trfn = trfn
### location of the geography text file
dec2$geogfn = geogfn
### Input the maximum range size
dec2$max_range_size = max_range_size
### Min to treat tip as a direct ancestor (no speciation event)
dec2$min_branchlength = 0.001
### set to FALSE for e.g. DEC* model, DEC*+J, etc.
dec2$include_null_range = FALSE
### input time strata and dispersal matrices
dec2$timesfn = timesfn
dec2$areas_allowed_fn = areas_allowed_fn
dec2$dispersal_multipliers_fn = dispersal_multipliers_fn
### loads the dispersal multiplier matrix
dec2 = readfiles_BioGeoBEARS_run(dec2)
### Divide the tree up by time periods
dec2 = section_the_tree(inputs=dec2,
make_master_table=TRUE,
plot_pieces=FALSE,
fossils_older_than=0.001,
cut_fossils=FALSE)
### Decribe stratified table:
dec2$master_table
### default settings to get ancestral states
dec2$return_condlikes_table = TRUE
dec2$calc_TTL_loglike_from_condlikes_table = TRUE
dec2$calc_ancprobs = TRUE    # get ancestral states from optim run
### computing options
dec2$num_cores_to_use = 1
### fitting DEC !
res_dec2 = bears_optim_run(dec2)
### save fitted model
save(res_dec2, file="7_biogeo_results/micro_DEC_2.Rdata")
###  biogeobears scripts
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))
### plotting
res_plot = plot_BioGeoBEARS_results(results_object= res_dec2,
addl_params=list("j"),
plotwhat="text",
label.offset=0.7,
tipcex=0.15,
statecex=0.4,
titlecex=0.8,
plotsplits= F,
cornercoords_loc= scriptdir,
include_null_range= F,
tr=tr,
tipranges=tipranges,
plotlegend = F)
### plotting
res_plot = plot_BioGeoBEARS_results(results_object= res_dec2,
addl_params=list("j"),
plotwhat="text",
label.offset=0.7,
tipcex=0.15,
statecex=0.4,
titlecex=0.8,
plotsplits= F,
cornercoords_loc= scriptdir,
include_null_range= F,
tr=tr,
tipranges=tipranges,
plotlegend = F)
### empty tables to hold the statistical results
restable = NULL
teststable = NULL
load("micro_DEC_0.RData")
load("micro_DEC_1.RData")
load("7_biogeo_resutls/micro_DEC_0.RData")
load("7_biogeo_results/micro_DEC_0.RData")
load("7_biogeo_results/micro_DEC_1.RData")
### empty tables to hold the statistical results
restable = NULL
teststable = NULL
LnL_0 = get_LnL_from_BioGeoBEARS_results_object(res_dec0)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(res_dec1)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(res_dec2)
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(res_dec2)
LnL_0 = get_LnL_from_BioGeoBEARS_results_object(res_dec0)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(res_dec1)
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(res_dec2)
LnL_0
LnL_1
LnL_2
extract_params_from_BioGeoBEARS_results_object(results_object=res_dec0,
returnwhat="table",
addl_params=c("j"),
paramsstr_digits=4)
extract_params_from_BioGeoBEARS_results_object(results_object=res_dec1,
returnwhat="table",
addl_params=c("j"),
paramsstr_digits=4)
### parameter values
param0 = extract_params_from_BioGeoBEARS_results_object(
results_object= res_dec0,
returnwhat= "table",
addl_params= c("j"),
paramsstr_digits= 4
)
param1 = extract_params_from_BioGeoBEARS_results_object(
results_object= res_dec1,
returnwhat= "table",
addl_params= c("j"),
paramsstr_digits= 4
)
param2 = extract_params_from_BioGeoBEARS_results_object(
results_object= res_dec2,
returnwhat= "table",
addl_params= c("j"),
paramsstr_digits= 4
)
source("0_scripts/calculate_aicc.R")
source("0_scripts/function_calculate_aicc.R")
param2
### likelihood
lnl0 = get_LnL_from_BioGeoBEARS_results_object(res_dec0)
lnl1 = get_LnL_from_BioGeoBEARS_results_object(res_dec1)
lnl2 = get_LnL_from_BioGeoBEARS_results_object(res_dec2)
calc_AIC_vals(LnL_vals = c(lnl0, lnl1,lnl2)
nparam_vals = c(2,2,2))
calc_AIC_vals(LnL_vals = c(lnl0, lnl1,lnl2),
nparam_vals = c(2,2,2))
calc_AIC_vals(LnL_vals = c(lnl0, lnl1,lnl2),
nparam_vals = c(2,2,2),
samplesize = 281)
calc_AIC_vals(LnL_vals = c(lnl0, lnl1,lnl2),
nparam_vals = c(2,2,2),
samplesize = c(281)
)
calc_AIC_vals(LnL_vals = c(lnl0, lnl1,lnl2),
nparam_vals = c(2,2,2)
)
