fsize= 0.15,
header = F,
colors = col_list,
space = 0,
xexp = 1.12,
yexp = 0.98
)
nodelabels(
node= (1+n_tips):(n_tips+n_anc),
pie = inner_node_probs,
piecol = full_col,
cex= 0.5
)
plot(tr)
plot(tr)
lines(
x=c(0.0000, 859.5811),
y=c(0, 283),
lwd=2
)
### load libraries
if(!require("tidyverse")) install.packages("tidyverse"); library("tidyverse")
if(!require("ggplot2")) install.packages("ggplot2"); library("ggplot2")
if(!require("phangorn")) install.packages("phangorn"); library("phangorn")
if(!require("ape")) install.packages("ape"); library("ape")
if(!require("seqinr")) install.packages("seqinr"); library("seqinr")
### file names
dir_input = "2_sequence_evaluation/ml_trees_clean/"
file_names = list.files(dir_input)
### loading data
tree_list = list()
for(i in 1:length(file_names) ){
tree_name = file_names[i]
tree_list[[i]] = read.tree(file = paste0(dir_input, tree_name))
names(tree_list)[i] =  str_remove(string = tree_name,
pattern = ".tree")
}
### file names
dir_input = "2_sequence_evaluation/ml_trees/"
file_names = list.files(dir_input)
### loading data
tree_list = list()
for(i in 1:length(file_names) ){
tree_name = file_names[i]
tree_list[[i]] = read.tree(file = paste0(dir_input, tree_name))
names(tree_list)[i] =  str_remove(string = tree_name,
pattern = ".tree")
}
### getting species per locus
all_names = c()
for(i in 1:length(tree_list)){
some_names = tree_list[[i]][[1]]$tip.label
all_names = c(all_names, some_names)
}
### phylogenetic tree location
trfn = "5_posterior/mcc.tree"
tr = read.tree(file = trfn)
### getting species per locus
all_names = c()
for(i in 1:length(tree_list)){
some_names = tree_list[[i]][[1]]$tip.label
all_names = c(all_names, some_names)
}
### into one dataframe
all_names = sort(unique(all_names))
### get names per locus
names_loci =  all_names
for(i in 1:length(tree_list)){
boll_names = all_names %in% tree_list[[i]][[1]]$tip.label
names_loci = cbind(names_loci, boll_names)
}
### transform to tibble
names_loci = as_tibble(names_loci)
### get species with all loci sequenced
common_names = names_loci %>%
filter_at(vars(-names_loci), all_vars(. == TRUE) ) %>%
select(names_loci) %>%
pull()
common_names
# pruning trees to sampled species
pruned_trees_list = tree_list
for (i in 1:length(tree_list) ){
pruned_trees = tree_list[[i]]
for(j in 1:length(tree_list[[i]]) ){
pruned_trees[[j]] = keep.tip(phy = tree_list[[i]][[j]],
tip = common_names)
}
pruned_trees_list[[i]] = pruned_trees
}
tr = keep.tip(phy = tr,
tip = common_names)
### transforming in vector
pruned_trees_vec = c()
for(i in 1:length(pruned_trees_list)){
pruned_trees_vec = c(pruned_trees_vec, pruned_trees_list[[i]] )
}
### distance
dist = RF.dist(
c(pruned_trees_list[[1]],
pruned_trees_list[[2]],
pruned_trees_list[[3]],
pruned_trees_list[[4]],
pruned_trees_list[[5]],
tr
),
tree2 = NULL,
normalize = T
)
tr
### getting vector with names for each distance
locus = c()
for(i in 1:length(pruned_trees_list)){
locus_name = names(pruned_trees_list)[i]
locus_rep = rep(locus_name, length.out= length(pruned_trees_list[[i]]) )
locus = c(locus, locus_rep)
}
### PCOA
pcoa = pcoa(dist, correction="none", rn=NULL)
pcoa_df = as.data.frame(cbind(locus, pcoa$vectors))
pcoa$vectors
locus
locus = c(locus, "MCC")
### PCOA
pcoa = pcoa(dist, correction="none", rn=NULL)
pcoa_df = as.data.frame(cbind(locus, pcoa$vectors))
### get % var
pc_rel_var = pcoa$values$Relative_eig
### axis names
pc_axis_1 = paste0("PCoA (", round(pc_rel_var[1]*100, 2), "%)" )
pc_axis_2 = paste0("PCoA (", round(pc_rel_var[2]*100, 2), "%)" )
### plot pcoa
pcoa_plot = ggplot(data = pcoa_df,
aes(x=as.numeric(Axis.1),
y=as.numeric(Axis.2),
color=locus)) +
geom_point(size = 1, alpha = 0.5) +
scale_colour_manual(values=c("ETS"= "darkred",
"ITS"= "darkorange",
"matK" = "darkorchid",
"trnDT" = "darkgreen",
"trnLF" = "darkblue",
"MCC" = "black"
)
)+
labs(x= pc_axis_1,
y= pc_axis_2)+
guides(color = guide_legend(title="",
ncol = 5,
byrow = TRUE) ) +
theme(panel.background=element_rect(fill="white"),
panel.grid=element_line(colour=NULL),
panel.border=element_rect(fill=NA,colour="black"),
axis.title=element_text(size=12,face="bold"),
legend.position = "bottom")
pcoa_plot
### export plot
tiff("2_sequence_evaluation/pcoa_ml_trees_MCC.tiff",
units="cm", width=10, height=9, res=600)
pcoa_plot
dev.off()
if(!require("phangorn")) install.packages("phangorn"); library("phangorn")
if(!require("ape")) install.packages("ape"); library("ape")
if(!require("seqinr")) install.packages("seqinr"); library("seqinr")
read.nexus.data("all_markers.nex")
nex = read.nexus.data("all_markers.nex")
View(nex)
### file names
dir_input = "2_sequence_evaluation/ml_trees/"
file_names = list.files(dir_input)
### loading data
tree_list = list()
for(i in 1:length(file_names) ){
tree_name = file_names[i]
tree_list[[i]] = read.tree(file = paste0(dir_input, tree_name))
names(tree_list)[i] =  str_remove(string = tree_name,
pattern = ".tree")
}
### load libraries
if(!require("tidyverse")) install.packages("tidyverse"); library("tidyverse")
if(!require("ggplot2")) install.packages("ggplot2"); library("ggplot2")
if(!require("phangorn")) install.packages("phangorn"); library("phangorn")
### loading data
tree_list = list()
for(i in 1:length(file_names) ){
tree_name = file_names[i]
tree_list[[i]] = read.tree(file = paste0(dir_input, tree_name))
names(tree_list)[i] =  str_remove(string = tree_name,
pattern = ".tree")
}
### getting species per locus
all_names = c()
for(i in 1:length(tree_list)){
some_names = tree_list[[i]][[1]]$tip.label
all_names = c(all_names, some_names)
}
### into one dataframe
all_names = sort(unique(all_names))
names(nex)
names(nex) %in% all_names
nex[names(nex) %in% all_names]
new_filt = nex[names(nex) %in% all_names]
nex_filt = nex[names(nex) %in% all_names]
rm(new_filt)
dividir_alinhamento_nexus <- function(arquivo_nexus,
particoes,
diretorio_saida = "alinhamentos_separados") {
# 1. Cria o diretório de saída se ele não existir
if (!dir.exists(diretorio_saida)) {
dir.create(diretorio_saida, recursive = TRUE)
cat(sprintf("Diretório de saída criado: '%s'\n", diretorio_saida))
}
# 2. Leitura do alinhamento NEXUS concatenado
cat(sprintf("Lendo o arquivo: %s\n", arquivo_nexus))
# A função read.nexus.data lê a matriz de alinhamento do bloco DATA/CHARACTERS
# e retorna um objeto do tipo 'list' (não DNAbin diretamente)
# Convertemos para DNAbin para facilitar o fatiamento e escrita posterior
aln_list <- read.nexus.data(arquivo_nexus)
aln_mat <- as.matrix(as.DNAbin(aln_list))
cat(sprintf("Alinhamento lido. Número de sequências: %d. Comprimento total: %d.\n",
nrow(aln_mat), ncol(aln_mat)))
# 3. Itera sobre as partições e fatia o alinhamento
alinhamentos_separados <- list()
for (marcador in names(particoes)) {
# Extrai as coordenadas de início e fim
inicio <- particoes[[marcador]][1]
fim <- particoes[[marcador]][2]
cat(sprintf("\nProcessando marcador: %s (posições %d a %d)...\n", marcador, inicio, fim))
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
# Converte de volta para o formato DNAbin (se necessário, para manter o tipo)
aln_marcador_db <- as.DNAbin(aln_marcador)
# Armazena na lista de resultados
alinhamentos_separados[[marcador]] <- aln_marcador_db
# 4. Salva o novo alinhamento NEXUS
nome_arquivo_saida <- file.path(diretorio_saida, paste0(marcador, ".nex"))
# write.nexus.data precisa de um objeto 'list' de vetores de caracteres,
# então revertemos de DNAbin (matriz) para o formato esperado (list)
write.nexus.data(
x = as.list(aln_marcador_db),
file = nome_arquivo_saida,
format = "DNA",
interleaved = FALSE # Geralmente melhor para a maioria dos programas
)
cat(sprintf("Arquivo salvo: '%s' (comprimento: %d)\n", nome_arquivo_saida, ncol(aln_marcador)))
}
cat("\nProcesso concluído!\n")
return(alinhamentos_separados)
}
# charset ETS=1-663;
# charset ITS=664-1864;
# charset matK=1865-3872;
# charset trnDT=3873-5900;
# charset trnLF=5901-7359;
particoes_marcadores <- list(
"ETS" = c(1, 663),
"ITS" = c(664, 1864),
"matK" = c(1865, 3872),
"trnDT" = c(3873, 5900),
"trnLF" = c(5901, 7359)
)
resultados <- dividir_alinhamento_nexus(
arquivo_nexus = nex_filt,
particoes = particoes_marcadores
)
dividir_alinhamento_nexus <- function(arquivo_nexus,
particoes,
diretorio_saida = "alinhamentos_separados") {
# 1. Cria o diretório de saída se ele não existir
if (!dir.exists(diretorio_saida)) {
dir.create(diretorio_saida, recursive = TRUE)
cat(sprintf("Diretório de saída criado: '%s'\n", diretorio_saida))
}
# 2. Leitura do alinhamento NEXUS concatenado
cat(sprintf("Lendo o arquivo: %s\n", arquivo_nexus))
# A função read.nexus.data lê a matriz de alinhamento do bloco DATA/CHARACTERS
# e retorna um objeto do tipo 'list' (não DNAbin diretamente)
# Convertemos para DNAbin para facilitar o fatiamento e escrita posterior
aln_mat <- as.matrix(as.DNAbin(aln_list))
cat(sprintf("Alinhamento lido. Número de sequências: %d. Comprimento total: %d.\n",
nrow(aln_mat), ncol(aln_mat)))
# 3. Itera sobre as partições e fatia o alinhamento
alinhamentos_separados <- list()
for (marcador in names(particoes)) {
# Extrai as coordenadas de início e fim
inicio <- particoes[[marcador]][1]
fim <- particoes[[marcador]][2]
cat(sprintf("\nProcessando marcador: %s (posições %d a %d)...\n", marcador, inicio, fim))
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
# Converte de volta para o formato DNAbin (se necessário, para manter o tipo)
aln_marcador_db <- as.DNAbin(aln_marcador)
# Armazena na lista de resultados
alinhamentos_separados[[marcador]] <- aln_marcador_db
# 4. Salva o novo alinhamento NEXUS
nome_arquivo_saida <- file.path(diretorio_saida, paste0(marcador, ".nex"))
# write.nexus.data precisa de um objeto 'list' de vetores de caracteres,
# então revertemos de DNAbin (matriz) para o formato esperado (list)
write.nexus.data(
x = as.list(aln_marcador_db),
file = nome_arquivo_saida,
format = "DNA",
interleaved = FALSE # Geralmente melhor para a maioria dos programas
)
cat(sprintf("Arquivo salvo: '%s' (comprimento: %d)\n", nome_arquivo_saida, ncol(aln_marcador)))
}
cat("\nProcesso concluído!\n")
return(alinhamentos_separados)
}
resultados <- dividir_alinhamento_nexus(
arquivo_nexus = nex_filt,
particoes = particoes_marcadores
)
names(particoes)
dividir_alinhamento_nexus <- function(arquivo_nexus,
particoes,
diretorio_saida = "alinhamentos_separados") {
# 1. Cria o diretório de saída se ele não existir
if (!dir.exists(diretorio_saida)) {
dir.create(diretorio_saida, recursive = TRUE)
cat(sprintf("Diretório de saída criado: '%s'\n", diretorio_saida))
}
# 2. Leitura do alinhamento NEXUS concatenado
cat(sprintf("Lendo o arquivo: %s\n", arquivo_nexus))
# A função read.nexus.data lê a matriz de alinhamento do bloco DATA/CHARACTERS
# e retorna um objeto do tipo 'list' (não DNAbin diretamente)
# Convertemos para DNAbin para facilitar o fatiamento e escrita posterior
aln_mat <- as.matrix(as.DNAbin(arquivo_nexus))
cat(sprintf("Alinhamento lido. Número de sequências: %d. Comprimento total: %d.\n",
nrow(aln_mat), ncol(aln_mat)))
# 3. Itera sobre as partições e fatia o alinhamento
alinhamentos_separados <- list()
for (marcador in names(particoes)) {
# Extrai as coordenadas de início e fim
inicio <- particoes[[marcador]][1]
fim <- particoes[[marcador]][2]
cat(sprintf("\nProcessando marcador: %s (posições %d a %d)...\n", marcador, inicio, fim))
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
# Converte de volta para o formato DNAbin (se necessário, para manter o tipo)
aln_marcador_db <- as.DNAbin(aln_marcador)
# Armazena na lista de resultados
alinhamentos_separados[[marcador]] <- aln_marcador_db
# 4. Salva o novo alinhamento NEXUS
nome_arquivo_saida <- file.path(diretorio_saida, paste0(marcador, ".nex"))
# write.nexus.data precisa de um objeto 'list' de vetores de caracteres,
# então revertemos de DNAbin (matriz) para o formato esperado (list)
write.nexus.data(
x = as.list(aln_marcador_db),
file = nome_arquivo_saida,
format = "DNA",
interleaved = FALSE # Geralmente melhor para a maioria dos programas
)
cat(sprintf("Arquivo salvo: '%s' (comprimento: %d)\n", nome_arquivo_saida, ncol(aln_marcador)))
}
cat("\nProcesso concluído!\n")
return(alinhamentos_separados)
}
resultados <- dividir_alinhamento_nexus(
arquivo_nexus = nex_filt,
particoes = particoes_marcadores
)
aln_mat <- as.matrix(as.DNAbin(nex_filt))
cat(sprintf("Alinhamento lido. Número de sequências: %d. Comprimento total: %d.\n",
nrow(aln_mat), ncol(aln_mat)))
# 3. Itera sobre as partições e fatia o alinhamento
alinhamentos_separados <- list()
names(particoes_marcadores )
marcador = "ETS"
# Extrai as coordenadas de início e fim
inicio <- particoes[[marcador]][1]
fim <- particoes[[marcador]][2]
# Extrai as coordenadas de início e fim
inicio <- particoes_marcadores[[marcador]][1]
fim <- particoes_marcadores[[marcador]][2]
cat(sprintf("\nProcessando marcador: %s (posições %d a %d)...\n", marcador, inicio, fim))
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
# Converte de volta para o formato DNAbin (se necessário, para manter o tipo)
aln_marcador_db <- as.DNAbin(aln_marcador)
aln_marcador
# write.nexus.data precisa de um objeto 'list' de vetores de caracteres,
# então revertemos de DNAbin (matriz) para o formato esperado (list)
write.nexus.data(
x = as.list(aln_marcador),
file = marcador,
format = "DNA",
interleaved = FALSE # Geralmente melhor para a maioria dos programas
)
write.fasta(
sequences = as.list(aln_marcador),
file.out = marcador,
open = "w" # 'w' para escrever, criando ou sobrescrevendo o arquivo
)
write.fasta(
sequences = as.list(aln_marcador),
names = names(aln_marcador),
file.out = marcador,
open = "w" # 'w' para escrever, criando ou sobrescrevendo o arquivo
)
write.fasta(
sequences = aln_marcador,
as.string = T,
names = spp_names,
file.out = marcador,
nbchar = 100
)
names(aln_marcador)
rownames(aln_marcador)
write.fasta(
sequences = aln_marcador,
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
as.list(aln_marcador)
write.fasta(
sequences = as.list(aln_marcador),
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
### convert back to matrix
mtx_trim = as.matrix(as.character(aln_marcador))
### check if there sites left
if(ncol(mtx_trim) > 0){
### convert back to list
list_trim = list()
for(i in 1:nrow(mtx_trim)){
list_trim[[i]] = paste0(mtx_trim[i,], collapse = "")
}
write.fasta(
sequences = as.list(aln_marcador),
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
}
### convert back to matrix
mtx_trim = as.matrix(as.character(aln_marcador))
### check if there sites left
if(ncol(mtx_trim) > 0){
### convert back to list
list_trim = list()
for(i in 1:nrow(mtx_trim)){
list_trim[[i]] = paste0(mtx_trim[i,], collapse = "")
}
}
list_trim
write.fasta(
sequences = list_trim,
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
for (marcador in names(particoes_marcadores )) {
# Extrai as coordenadas de início e fim
inicio <- particoes_marcadores[[marcador]][1]
fim <- particoes_marcadores[[marcador]][2]
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
### convert back to matrix
mtx_trim = as.matrix(as.character(aln_marcador))
### check if there sites left
if(ncol(mtx_trim) > 0){
### convert back to list
list_trim = list()
for(i in 1:nrow(mtx_trim)){
list_trim[[i]] = paste0(mtx_trim[i,], collapse = "")
}
}
write.fasta(
sequences = list_trim,
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
}
for (marcador in names(particoes_marcadores )) {
# Extrai as coordenadas de início e fim
inicio <- particoes_marcadores[[marcador]][1]
fim <- particoes_marcadores[[marcador]][2]
# Fatiamento da matriz de alinhamento
# [todas as linhas (sequências), colunas do início ao fim]
aln_marcador <- aln_mat[, inicio:fim]
### convert back to matrix
mtx_trim = as.matrix(as.character(aln_marcador))
### check if there sites left
if(ncol(mtx_trim) > 0){
### convert back to list
list_trim = list()
for(i in 1:nrow(mtx_trim)){
list_trim[[i]] = paste0(mtx_trim[i,], collapse = "")
}
}
write.fasta(
sequences = list_trim,
as.string = T,
names = rownames(aln_marcador),
file.out = marcador,
nbchar = 100
)
}
